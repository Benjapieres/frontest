const fs = require('fs');
const path = require('path');
const { calculateStats, groupErrorsByType } = require('../utils/stats-calculator');

/**
 * Exports sitemap verification results to Markdown format
 */

function generateMarkdownReport(sitemapUrl, results, duration) {
  const stats = calculateStats(results);
  const errors = groupErrorsByType(results);
  const durationSec = Math.round(duration / 100) / 10;

  let markdown = '# Sitemap Verification Report\n\n';

  // Metadata
  markdown += `**Generated:** ${new Date().toLocaleString()}\n\n`;
  markdown += `**Sitemap URL:** ${sitemapUrl}\n\n`;
  markdown += `**Duration:** ${durationSec}s\n\n`;

  // Summary Table
  markdown += '## Summary\n\n';
  markdown += '| Metric | Value |\n';
  markdown += '|--------|-------|\n';
  markdown += `| Total URLs | ${stats.totalUrls} |\n`;
  markdown += `| Successful | ${stats.successful} (${stats.successRate.toFixed(2)}%) |\n`;
  markdown += `| Failed | ${stats.failed} (${(100 - stats.successRate).toFixed(2)}%) |\n`;
  markdown += `| Avg Response Time | ${stats.avgResponseTime}ms |\n`;
  markdown += `| Min Response Time | ${stats.minResponseTime}ms |\n`;
  markdown += `| Max Response Time | ${stats.maxResponseTime}ms |\n`;
  markdown += `| P50 Response Time | ${stats.p50}ms |\n`;
  markdown += `| P95 Response Time | ${stats.p95}ms |\n`;
  markdown += `| P99 Response Time | ${stats.p99}ms |\n\n`;

  // Status Code Distribution
  markdown += '## Status Code Distribution\n\n';
  markdown += '| Status Code | Count | Percentage |\n';
  markdown += '|-------------|-------|------------|\n';

  Object.entries(stats.statusCodeCounts)
    .sort((a, b) => parseInt(b[0]) - parseInt(a[0]))
    .forEach(([code, count]) => {
      const percentage = ((count / stats.totalUrls) * 100).toFixed(1);
      markdown += `| ${code} | ${count} | ${percentage}% |\n`;
    });

  markdown += '\n';

  // Failed URLs by Status Code
  if (Object.keys(errors).length > 0) {
    markdown += '## Failed URLs\n\n';

    Object.entries(errors)
      .sort((a, b) => parseInt(b[0]) - parseInt(a[0]))
      .forEach(([statusCode, failedUrls]) => {
        markdown += `### Status ${statusCode} (${failedUrls.length} errors)\n\n`;
        failedUrls.slice(0, 100).forEach(failure => {
          markdown += `- \`${failure.url}\`\n`;
        });

        if (failedUrls.length > 100) {
          markdown += `- ... and ${failedUrls.length - 100} more\n`;
        }

        markdown += '\n';
      });
  }

  // Results Table (top 100)
  markdown += '## URL Results (First 100)\n\n';
  markdown += '| URL | Status | Response Time | Attempts |\n';
  markdown += '|-----|--------|----------------|----------|\n';

  results.slice(0, 100).forEach(result => {
    const statusEmoji = result.statusCode >= 200 && result.statusCode < 300 ? '✅' :
                       result.statusCode >= 300 && result.statusCode < 400 ? 'ℹ️' :
                       '❌';
    markdown += `| ${result.url.substring(0, 50)}... | ${statusEmoji} ${result.statusCode || 'N/A'} | ${result.responseTime}ms | ${result.attempts} |\n`;
  });

  if (results.length > 100) {
    markdown += `\n*... and ${results.length - 100} more URLs not shown*\n`;
  }

  markdown += '\n';

  // Footer
  markdown += '---\n\n';
  markdown += '*Generated by Sitemap Verification Bot*\n';

  return markdown;
}

function saveMarkdownReport(markdownContent, filename) {
  return new Promise((resolve, reject) => {
    try {
      const reportsDir = './reports';
      if (!fs.existsSync(reportsDir)) {
        fs.mkdirSync(reportsDir, { recursive: true });
      }

      const filepath = path.join(reportsDir, filename);
      fs.writeFileSync(filepath, markdownContent, 'utf-8');
      resolve(filepath);
    } catch (error) {
      reject(error);
    }
  });
}

module.exports = {
  generateMarkdownReport,
  saveMarkdownReport
};
